# go

## ✈go的gc

## 🙂go中的数据类型

## 😋go的函数

> 😋传统内存管理[^1]
>

> 🐱‍🏍go_数据类型大纲[^2]
>
>
>
>
>
>

> 🤨go_函数[^3]
>

## ✈go的作用域

## 🙂go的指针

## 😋

> 😋go_变量作用域[^4]
>

> 🐱‍🏍go_指针入门[^5]
>
>
>
>
>
>

> 🤨
>


[^1]: # 传统内存管理

    ## 1.垃圾的存在

    * C++/C中申请动态内存，需要手动进行释放。


    ## 2.回收垃圾的办法

    * 静态的代码扫描
    * 智能指针（通过拥有自动内存管理功能的**指针对象**来引用对象）

    * 垃圾回收：内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。使用者只用关心申请了，而不用关心内存的释放了。


    ## 3.垃圾回收

    #### 引用计数

    **理解：**这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减1，当被引用对象被创建或被赋值给其他对象时引用计数自动加1。当引用计数为0时则立即回收对象。（其实和静态代码扫描有点相似，只不过这应该是自动进行的）

    **特点：**

    * 频繁更新引用计数降低了性能。
    * 循环引用问题，当对象间发生循环引用时引用链中的对象都无法得到释放。


    #### 标记清除

    **理解**：

        标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收。

    **特点**：

    * 能比较好的解决循环引用。
    * 但是启动垃圾回收会影响正常代码的执行。


    #### 分代收集

    **理解：**

        分代收集的基本思想是，将堆划分为两个或多个称为 代（generation）的空间。新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion）到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。


    ## 


[^2]: # go_数据类型大纲

    |序号|类型和描述|
    | ------| -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    |1|**布尔型**<br />布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。|
    |2|**数字类型**<br />整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。|
    |3|**字符串类型:**<br />字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。|
    |4|**派生类型:**<br />包括：* (a) 指针类型（Pointer）* (b) 数组类型* (c) 结构化类型(struct)* (d) Channel 类型* (e) 函数类型* (f) 切片类型* (g) 接口类型（interface）* (h) Map 类型|

    ## 数字类型

    Go 也有基于架构的类型，例如：int、uint 和 uintptr。

    |序号|类型和描述|
    | ------| ---------------------------------------------------------------------------------|
    |1|**uint8**<br />无符号 8 位整型 (0 到 255)|
    |2|**uint16**<br />无符号 16 位整型 (0 到 65535)|
    |3|**uint32**<br />无符号 32 位整型 (0 到 4294967295)|
    |4|**uint64**<br />无符号 64 位整型 (0 到 18446744073709551615)|
    |5|**int8**<br />有符号 8 位整型 (-128 到 127)|
    |6|**int16**<br />有符号 16 位整型 (-32768 到 32767)|
    |7|**int32**<br />有符号 32 位整型 (-2147483648 到 2147483647)|
    |8|**int64**<br />有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)|

    ### 浮点型

    |序号|类型和描述|
    | ------| ------------------------------------------|
    |1|**float32**<br />IEEE-754 32位浮点型数|
    |2|**float64**<br />IEEE-754 64位浮点型数|
    |3|**complex64**<br />32 位实数和虚数|
    |4|**complex128**<br />64 位实数和虚数|

    ---

    ## 其他数字类型

    以下列出了其他更多的数字类型：

    |序号|类型和描述|
    | ------| -------------------------------------------------|
    |1|**byte**<br />类似 uint8|
    |2|**rune**<br />类似 int32|
    |3|**uint**<br />32 或 64 位|
    |4|**int**<br />与 uint 一样大小|
    |5|**uintptr**<br />无符号整型，用于存放一个指针|


[^3]: # go_函数

    ## 函数定义

    Go 语言函数定义格式如下：

    ```
    func function_name([parameter list])[return_types]{
       函数体
    }
    ```

    函数定义解析：

    * func：函数由 func 开始声明
    * function_name：函数名称，参数列表和返回值类型构成了函数签名。
    * parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
    * return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。
    * 函数体：函数定义的代码集合。

    ### 实例

    以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：

    ## 实例

    ```go

    /* 函数返回两个数的最大值 */
    func max(num1, num2 int) int {
       /* 声明局部变量 */
       var result int

       if (num1 > num2) {
          result = num1
       } else {
          result = num2
       }
       return result
    }
    ```

    ## 函数调用

    当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。

    调用函数，向函数传递参数，并返回值，例如：

    ## 实例

    ```go
    package main

    import "fmt"

    func main() {
       /* 定义局部变量 */
       var a int = 100
       var b int = 200
       var ret int
    ```

    **以上实例在 main() 函数中调用 max（）函数，执行结果为：**

    ```
    最大值是:200
    ```

    ---

    ## 函数返回多个值

    Go 函数可以返回多个值，例如：

    ## 实例

    ```go
    package main

    import "fmt"

    func swap(x, y string) (string, string) {
       return y, x
    }

    func main() {
       a, b := swap("Google", "Runoob")
       fmt.Println(a, b)
    }
    ```

    **以上实例执行结果为：**

    ```
    RunoobGoogle
    ```

    ---

    ## 函数参数

    函数如果使用参数，该变量可称为函数的形参。

    形参就像定义在函数体内的局部变量。

    调用函数，可以通过两种方式来传递参数：

    |传递类型|描述|
    | ----------| --------------------------------------------------------------------------------------------------------------|
    |值传递|值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。|
    |引用传递|引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。|

    默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。

    ---

    ## 函数用法


    #### 函数作为另外一个函数的实参。（这个比较的常用吧）

    ```go
    package main

    import (
       "fmt"
       "math"
    )

    func main(){
       /* 声明函数变量 */
       getSquareRoot := func(x float64) float64 {
          return math.Sqrt(x)
       }

       /* 使用函数 */
       fmt.Println(getSquareRoot(9))

    }
    ```


    #### go语言的闭包

    Go 语言支持匿名函数，可作为闭包。匿名函数是一个"内联"语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。

    以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：

    ```go
    package main

    import "fmt"

    //竟然可以返回一个函数
    func getSequence() func() int {
       i:=0
       return func() int {
          i+=1
         return i  
       }
    }

    func main(){
       /* nextNumber 为一个函数，函数 i 为 0 */
       nextNumber := getSequence()  

       /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
       fmt.Println(nextNumber())
       fmt.Println(nextNumber())
       fmt.Println(nextNumber())
       
       /* 创建新的函数 nextNumber1，并查看结果 */
       nextNumber1 := getSequence()  
       fmt.Println(nextNumber1())
       fmt.Println(nextNumber1())
    }
    ```

    **结果：**

    ```go
    1
    2
    3
    1
    2
    ```

    * 这里应该和作用域有关系了
    * 有点类似于一种特殊的结构体了


    #### go语言函数的方法

    Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：

    ```
    func (variable_name variable_data_type) function_name()[return_type]{
       /* 函数体*/
    }
    ```

    下面定义一个结构体类型和该类型的一个方法：

    ## 实例

    ```go
    package main

    import (
       "fmt"  
    )

    /* 定义结构体 */
    type Circle struct {
      radius float64
    }

    func main() {
      var c1 Circle
      c1.radius = 10.00
      fmt.Println("圆的面积 = ", c1.getArea())
    }

    //该 method 属于 Circle 类型对象中的方法
    //我觉得这只是一种特殊的写法罢了
    func (c Circle) getArea() float64 {
      //c.radius 即为 Circle 类型对象中的属性
      return 3.14 * c.radius * c.radius
    }
    ```

    以上代码执行结果为：

    ```
    圆的面积=314
    ```

    * 这里是强行给一个类型声明上方法


[^4]: # go_变量作用域

    ## 1.go的变量类型

    * 函数内定义的变量称为局部变量
    * 函数外定义的变量称为全局变量
    * 函数定义中的变量称为形式参数


    ### 局部变量

    在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

    以下实例中 main() 函数使用了局部变量 a, b, c：

    #### 实例

    ```go
    package main

    import "fmt"

    func main() {
       /* 声明局部变量 */
       var a, b, c int

       /* 初始化参数 */
       a = 10
       b = 20
       c = a + b

       fmt.Printf ("结果： a = %d, b = %d and c = %d\n", a, b, c)
    }
    ```

    **以上实例执行输出结果为：**

    ```
    结果： a =10, b =20and c =30
    ```

    ---


    ### 全局变量

    在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。

    全局变量可以在任何函数中使用，以下实例演示了如何使用全局变量：

    #### 实例

    ```go
    package main

    import "fmt"

    /* 声明全局变量 */
    var g int

    func main() {

       /* 声明局部变量 */
       var a, b int

       /* 初始化参数 */
       a = 10
       b = 20
       g = a + b

       fmt.Printf("结果： a = %d, b = %d and g = %d\n", a, b, g)
    }
    ```

    **以上实例执行输出结果为：**

    ```
    结果： a =10, b =20and g =30
    ```

    **Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。实例如下：**


    #### 

    ```go

    package main

    import "fmt"

    /* 声明全局变量 */
    var g int = 20

    func main() {
       /* 声明局部变量 */
       var g int = 10

       fmt.Printf ("结果： g = %d\n",  g)
    }
    ```

     ``

    **以上实例执行输出结果为：**

    ```
    结果： g =10
    ```

    ---


    ### 形式参数

    形式参数会作为函数的局部变量来使用。实例如下：


    #### 实例

    ```go
    package main

    import "fmt"

    /* 声明全局变量 */
    var a int = 20;

    func main() {
       /* main 函数中声明局部变量 */
       var a int = 10
       var b int = 20
       var c int = 0

       fmt.Printf("main()函数中 a = %d\n",  a);
       c = sum( a, b);
       fmt.Printf("main()函数中 c = %d\n",  c);
    }

    /* 函数定义-两数相加 */
    func sum(a, b int) int {
       fmt.Printf("sum() 函数中 a = %d\n",  a);
       fmt.Printf("sum() 函数中 b = %d\n",  b);

       return a + b;
    }
    ```

    **以上实例执行输出结果为：**

    ```
    main()函数中 a =10
    sum()函数中 a =10
    sum()函数中 b =20
    main()函数中 c =30
    ```

    ---


    ### 初始化局部和全局变量

    不同类型的局部和全局变量默认值为：

    |数据类型|初始化默认值|
    | ----------| --------------|
    |int|0|
    |float32|0|
    |pointer|nil|


[^5]: # go_指针入门

    ## 1.Go 语言指针

    我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。

    Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。

    以下实例演示了变量在内存中地址：

    #### 实例

    ```go
    package main

    import "fmt"

    func main() {
       var a int = 10

       fmt.Printf("变量的地址: %x\n", &a  )
    }
    ```

    **执行以上代码输出结果为：**

    ```
    变量的地址:20818a220
    ```


    ## 2.go里面指针的声明

    一个指针变量指向了一个值的内存地址。

    类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：

    ```
    var var_name *var-type
    ```

    var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：

    ```
    var ip *int/* 指向整型*/
    var fp *float32    /* 指向浮点型 */
    ```

    本例中这是一个指向 int 和 float32 的指针。


    ## 3.如何使用指针（和C++差不多）

    指针使用流程：

    * 定义指针变量。
    * 为指针变量赋值。
    * 访问指针变量中指向地址的值。

    在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。（和C++差不多）

    #### 实例

    ```go
    package main

    import "fmt"

    func main() {
       var a int= 20   /* 声明实际变量 */
       var ip *int        /* 声明指针变量 */

       ip = &a  /* 指针变量的存储地址 */

       fmt.Printf("a 变量的地址是: %x\n", &a  )

       /* 指针变量的存储地址 */
       fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

       /* 使用指针访问值 */
       fmt.Printf("*ip 变量的值: %d\n", *ip )
    }
    //
    ```

    **以上实例执行输出结果为：**

    ```
    a 变量的地址是:20818a220
    ip 变量储存的指针地址:20818a220
    *ip 变量的值:20
    ```

    ---


    ## 4.Go 空指针

    当一个指针被定义后没有分配到任何变量时，它的值为 nil。

    nil 指针也称为空指针。

    nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。

    一个指针变量通常缩写为 ptr。

    查看以下实例：


    #### 实例

    ```go
    package main

    import "fmt"

    func main() {
       var  ptr *int

       fmt.Printf("ptr 的值为 : %x\n", ptr  )
    }
    ```

    **以上实例输出结果为：**

    ```
    ptr 的值为:0
    ```

    **空指针判断：**

    ```
    if(ptr !=nil)/* ptr 不是空指针 */
    if(ptr ==nil)/* ptr 是空指针 */
    ```
