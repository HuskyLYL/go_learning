# 传统内存管理

## 1.垃圾的存在

* C++/C中申请动态内存，需要手动进行释放。


## 2.回收垃圾的办法

* 静态的代码扫描
* 智能指针（通过拥有自动内存管理功能的**指针对象**来引用对象）

* 垃圾回收：内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的行为就被称为垃圾回收。使用者只用关心申请了，而不用关心内存的释放了。


## 3.垃圾回收

#### 引用计数

**理解：**这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减1，当被引用对象被创建或被赋值给其他对象时引用计数自动加1。当引用计数为0时则立即回收对象。（其实和静态代码扫描有点相似，只不过这应该是自动进行的）

**特点：**

* 频繁更新引用计数降低了性能。
* 循环引用问题，当对象间发生循环引用时引用链中的对象都无法得到释放。


#### 标记清除

**理解**：

    标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收。

**特点**：

* 能比较好的解决循环引用。
* 但是启动垃圾回收会影响正常代码的执行。


#### 分代收集

**理解：**

    分代收集的基本思想是，将堆划分为两个或多个称为 代（generation）的空间。新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion）到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。


##
